<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Gui4jTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gui4j</a> &gt; <a href="index.source.html" class="el_package">org.gui4j.component</a> &gt; <span class="el_source">Gui4jTree.java</span></div><h1>Gui4jTree.java</h1><pre class="source lang-java linenums">package org.gui4j.component;

import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.swing.Icon;
import javax.swing.JTree;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.gui4j.Gui4jCallBase;
import org.gui4j.Gui4jGetValue;
import org.gui4j.core.Gui4jCall;
import org.gui4j.core.Gui4jComponentContainer;
import org.gui4j.core.Gui4jComponentInstance;
import org.gui4j.core.Gui4jMap1;
import org.gui4j.core.Gui4jMouseListener;
import org.gui4j.core.Gui4jQualifiedComponent;
import org.gui4j.core.Gui4jSwingContainer;
import org.gui4j.core.Gui4jThreadManager;
import org.gui4j.core.Gui4jTypeManager;
import org.gui4j.core.listener.Gui4jMouseListenerTree;
import org.gui4j.event.Gui4jEventListener;
import org.gui4j.util.Utils;

public final class Gui4jTree extends Gui4jJComponent {
  public static final String PARAM_ITEM = &quot;item&quot;;
  public static final String PARAM_PATH = &quot;path&quot;;

  public static final int COMMAND_COLLAPSE = 1;
  public static final int COMMAND_EXPAND = 2;
  public static final int COMMAND_SETROOT = 3;
  public static final int COMMAND_RESETROOT = 4;
  public static final int COMMAND_COLLAPSE_ALL = 5;
  public static final int COMMAND_EXPAND_ALL = 6;

<span class="nc" id="L62">  protected static final Log log = LogFactory.getLog(Gui4jTree.class);</span>

<span class="nc" id="L64">  protected final Gui4jTypeManager nodeManager = new Gui4jTypeManager();</span>
  protected final boolean mLazy;
  protected final boolean mHideRootNode;
  protected final boolean mUseOriginalCollection;
  protected final boolean mInitiallyExpand;

  protected Gui4jCall[] mRefreshEvents;
  protected Gui4jCall onSelectCallTree;
  protected Gui4jCall mSelectedNode;
  protected Gui4jCall mSelectedPath;
  protected Gui4jCall mLazyMessageCall;

  public Gui4jTree(
      Gui4jComponentContainer gui4jComponentContainer,
      String id,
      boolean lazy,
      boolean hideRootNode,
      boolean useOriginalCollection,
      boolean initiallyExpand) {
<span class="nc" id="L83">    super(gui4jComponentContainer, JTree.class, id);</span>

<span class="nc" id="L85">    this.mLazy = lazy;</span>
<span class="nc" id="L86">    this.mHideRootNode = hideRootNode;</span>
<span class="nc" id="L87">    this.mUseOriginalCollection = useOriginalCollection;</span>
<span class="nc" id="L88">    this.mInitiallyExpand = initiallyExpand;</span>
<span class="nc" id="L89">  }</span>

  public void setRoot(Gui4jComponentInstance componentInstance, Object root) {
<span class="nc" id="L92">    Gui4jJTree tree = (Gui4jJTree) componentInstance.getSwingComponent();</span>

<span class="nc" id="L94">    log.debug(&quot;Received request to set new root for tree with id &quot; + getId());</span>

    // determine selection in new tree
<span class="nc" id="L97">    Object node = tree.getLastSelectedPathComponent();</span>
<span class="nc" id="L98">    Object[] path = null;</span>

<span class="nc bnc" id="L100" title="All 2 branches missed.">    if (mSelectedPath != null) {</span>
<span class="nc" id="L101">      path = (Object[]) mSelectedPath.getValueNoParams(componentInstance.getGui4jCallBase(), node);</span>
    }

<span class="nc bnc" id="L104" title="All 2 branches missed.">    if (mSelectedNode != null) {</span>
<span class="nc" id="L105">      node = mSelectedNode.getValueNoParams(componentInstance.getGui4jCallBase(), node);</span>
    }

    // change root of tree model
<span class="nc" id="L109">    Gui4jTreeRootChanger rootChanger = new Gui4jTreeRootChanger(tree, root, path, node);</span>
<span class="nc" id="L110">    rootChanger.run(mLazy);</span>
<span class="nc" id="L111">  }</span>

  public void setReload(Gui4jComponentInstance componentInstance, Object[] reloadPath) {
<span class="nc" id="L114">    Gui4jJTree tree = (Gui4jJTree) componentInstance.getSwingComponent();</span>

<span class="nc bnc" id="L116" title="All 4 branches missed.">    if (reloadPath != null &amp;&amp; log.isDebugEnabled()) {</span>
<span class="nc" id="L117">      log.debug(&quot;Received request to reload path: &quot; + Arrays.asList(reloadPath));</span>
    }

    // determine selection in new tree
<span class="nc" id="L121">    Object node = null;</span>
<span class="nc" id="L122">    Object[] path = null;</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">    if (mSelectedPath != null) {</span>
<span class="nc" id="L125">      path = (Object[]) mSelectedPath.getValueNoParams(componentInstance.getGui4jCallBase(), node);</span>
    }

<span class="nc bnc" id="L128" title="All 2 branches missed.">    if (mSelectedNode != null) {</span>
<span class="nc" id="L129">      node = mSelectedNode.getValueNoParams(componentInstance.getGui4jCallBase(), node);</span>
    }

    // reload given path
<span class="nc" id="L133">    Gui4jTreeReloader reloader = new Gui4jTreeReloader(tree, reloadPath, path, node);</span>
<span class="nc" id="L134">    reloader.run(mLazy);</span>
<span class="nc" id="L135">  }</span>

  public void setSelectedNodeCall(Gui4jCall selectedNode) {
<span class="nc" id="L138">    mSelectedNode = selectedNode;</span>
<span class="nc" id="L139">  }</span>

  public void setSelectedPathCall(Gui4jCall selectedPath) {
<span class="nc" id="L142">    mSelectedPath = selectedPath;</span>
<span class="nc" id="L143">  }</span>

  public void setSelectedNode(JTree tree, Object node) {
<span class="nc bnc" id="L146" title="All 2 branches missed.">    if (node == null) {</span>
<span class="nc" id="L147">      return;</span>
    }

<span class="nc" id="L150">    log.debug(&quot;Setting tree node selection to node: &quot; + node);</span>
<span class="nc" id="L151">    Gui4jTreeSelector selector = new Gui4jTreeSelector(tree, node);</span>
<span class="nc" id="L152">    selector.run(mLazy);</span>
<span class="nc" id="L153">  }</span>

  public void setSelectedPath(JTree tree, Object[] path) {
<span class="nc bnc" id="L156" title="All 2 branches missed.">    if (path == null) {</span>
<span class="nc" id="L157">      return;</span>
    }

<span class="nc" id="L160">    log.debug(&quot;Delegating to Gui4jTreeSelector, path: &quot; + Arrays.asList(path));</span>

<span class="nc" id="L162">    Gui4jTreeSelector selector = new Gui4jTreeSelector(tree, path);</span>
<span class="nc" id="L163">    selector.run(mLazy);</span>
<span class="nc" id="L164">  }</span>

  public void addNode(
      Class clazz,
      Gui4jCall value,
      Gui4jCall children,
      Gui4jCall onSelectCall,
      Gui4jCall onDblClickCall,
      Gui4jCall iconCall,
      Gui4jCall isLeafCall,
      String iconPosition,
      boolean lazy) {
    // convert from icon position to text position
<span class="nc" id="L177">    int textPosition = SwingConstants.TRAILING;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">    if (iconPosition.equals(&quot;trailing&quot;)) {</span>
<span class="nc" id="L179">      textPosition = SwingConstants.LEADING;</span>
    }

<span class="nc" id="L182">    Gui4jTreeNode node =</span>
        new Gui4jTreeNode(
            value,
            children,
            onSelectCall,
            onDblClickCall,
            iconCall,
            isLeafCall,
            textPosition,
            lazy);
<span class="nc" id="L192">    nodeManager.add(clazz, node);</span>
<span class="nc" id="L193">  }</span>

  public void setRefreshEvents(Gui4jCall[] calls) {
<span class="nc" id="L196">    mRefreshEvents = calls;</span>
<span class="nc" id="L197">  }</span>

  public void setOnSelectCallTree(Gui4jCall call) {
<span class="nc" id="L200">    onSelectCallTree = call;</span>
<span class="nc" id="L201">  }</span>

  public void setLazyMessageCall(Gui4jCall call) {
<span class="nc" id="L204">    mLazyMessageCall = call;</span>
<span class="nc" id="L205">  }</span>

  protected Gui4jComponentInstance createComponentInstance(
      Gui4jSwingContainer gui4jSwingContainer,
      Gui4jCallBase gui4jCallBase,
      Gui4jQualifiedComponent gui4jQualifiedComponent) {
<span class="nc" id="L211">    Gui4jTreeModel treeModel = new Gui4jTreeModel(gui4jCallBase, gui4jSwingContainer);</span>
<span class="nc" id="L212">    Gui4jJTree tree = new Gui4jJTree(treeModel);</span>
<span class="nc" id="L213">    treeModel.setSelectionModel(tree.getSelectionModel());</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">    tree.setRootVisible(!mHideRootNode);</span>
<span class="nc" id="L216">    registerEvents(</span>
<span class="nc" id="L217">        gui4jSwingContainer, gui4jCallBase, mRefreshEvents, treeModel.getRefreshListener());</span>
<span class="nc" id="L218">    Gui4jComponentInstance gui4jComponentInstance =</span>
        new Gui4jComponentInstance(gui4jSwingContainer, tree, gui4jQualifiedComponent);
<span class="nc" id="L220">    return gui4jComponentInstance;</span>
  }

  protected Gui4jMouseListener createMouseListener(Gui4jComponentInstance gui4jComponentInstance) {
<span class="nc" id="L224">    return new Gui4jMouseListenerTree(gui4jComponentInstance);</span>
  }

  /*
   * @see de.bea.gui4j.Gui4jAbstractComponent#getPopupContext(de.bea.gui4j.Gui4jComponentInstance,
   *      java.awt.event.MouseEvent)
   */
  protected Object getPopupContext(
      Gui4jComponentInstance gui4jComponentInstance, MouseEvent mouseEvent) {
<span class="nc" id="L233">    JTree tree = (JTree) gui4jComponentInstance.getComponent();</span>
<span class="nc" id="L234">    Object selectedNode = tree.getLastSelectedPathComponent();</span>
<span class="nc" id="L235">    return selectedNode;</span>
  }

  /*
   * (non-Javadoc)
   *
   * @see de.bea.gui4j.Gui4jAbstractComponent#getPopupLocation(de.bea.gui4j.Gui4jComponentInstance,
   *      java.awt.event.MouseEvent, java.lang.Object)
   */
  protected Point getPopupLocation(
      Gui4jComponentInstance gui4jComponentInstance, MouseEvent mouseEvent, Object context) {
<span class="nc bnc" id="L246" title="All 2 branches missed.">    if (context == null) {</span>
<span class="nc" id="L247">      return null;</span>
    }
<span class="nc bnc" id="L249" title="All 2 branches missed.">    if (mouseEvent != null) {</span>
<span class="nc" id="L250">      return mouseEvent.getPoint();</span>
    }

<span class="nc" id="L253">    Gui4jJTree tree = (Gui4jJTree) gui4jComponentInstance.getComponent();</span>
<span class="nc" id="L254">    TreePath path = tree.getGui4jTreeModel().getCoreModel().getPath(context, true);</span>
<span class="nc" id="L255">    Rectangle selection = tree.getUI().getPathBounds(tree, path);</span>
<span class="nc" id="L256">    return new Point(selection.x + selection.width, selection.y + selection.height);</span>
  }

  public void handleAction(
      Gui4jComponentInstance gui4jComponentInstance, Object context, int command) {

<span class="nc" id="L262">    Gui4jJTree tree = (Gui4jJTree) gui4jComponentInstance.getSwingComponent();</span>
<span class="nc" id="L263">    Gui4jTreeModel model = (Gui4jTreeModel) tree.getModel();</span>

<span class="nc bnc" id="L265" title="All 4 branches missed.">    switch (command) {</span>
      case COMMAND_COLLAPSE:
      case COMMAND_COLLAPSE_ALL:
      case COMMAND_EXPAND:
      case COMMAND_EXPAND_ALL:
        {
<span class="nc" id="L271">          Gui4jTreeExpander expander = new Gui4jTreeExpander(tree, context, command);</span>
<span class="nc" id="L272">          expander.run(mLazy);</span>
        }
<span class="nc" id="L274">        break;</span>

      case COMMAND_SETROOT:
<span class="nc" id="L277">        System.out.println(&quot;Tree: setroot - &quot; + context);</span>
<span class="nc" id="L278">        model.switchDisplayRoot(context);</span>
<span class="nc" id="L279">        break;</span>

      case COMMAND_RESETROOT:
<span class="nc" id="L282">        System.out.println(&quot;Tree: resetroot&quot;);</span>
<span class="nc" id="L283">        model.switchDisplayRootToMasterRoot();</span>
        break;
    }
<span class="nc" id="L286">  }</span>

  // **********************************************************************

  /**
   * Encapsulates reflection calls and attributes specified for a certain type (i.e. class) of node.
   */
  private static class Gui4jTreeNode {
    private final Gui4jCall valueCall;
    private final Gui4jCall childrenCall;
    private final Gui4jCall onSelectCall;
    private final Gui4jCall onDblClickCall;
    private final Gui4jCall iconCall;
    private final Gui4jCall isLeafCall;
    private final int textPosition;
    protected final boolean lazy;

    public Gui4jTreeNode(
        Gui4jCall value,
        Gui4jCall children,
        Gui4jCall onSelectCall,
        Gui4jCall onDblClickCall,
        Gui4jCall iconCall,
        Gui4jCall isLeafCall,
        int textPosition,
<span class="nc" id="L311">        boolean lazy) {</span>
<span class="nc" id="L312">      this.valueCall = value;</span>
<span class="nc" id="L313">      this.childrenCall = children;</span>
<span class="nc" id="L314">      this.onSelectCall = onSelectCall;</span>
<span class="nc" id="L315">      this.onDblClickCall = onDblClickCall;</span>
<span class="nc" id="L316">      this.iconCall = iconCall;</span>
<span class="nc" id="L317">      this.isLeafCall = isLeafCall;</span>
<span class="nc" id="L318">      this.textPosition = textPosition;</span>
<span class="nc" id="L319">      this.lazy = lazy;</span>
<span class="nc" id="L320">    }</span>

    public Gui4jCall getChildrenCall() {
<span class="nc" id="L323">      return childrenCall;</span>
    }

    public Gui4jCall getValueCall() {
<span class="nc" id="L327">      return valueCall;</span>
    }

    public Gui4jCall getOnSelectCall() {
<span class="nc" id="L331">      return onSelectCall;</span>
    }

    public Gui4jCall getOnDblClickCall() {
<span class="nc" id="L335">      return onDblClickCall;</span>
    }

    public Gui4jCall getIconCall() {
<span class="nc" id="L339">      return iconCall;</span>
    }

    public int getTextPosition() {
<span class="nc" id="L343">      return textPosition;</span>
    }

    public Gui4jCall getIsLeafCall() {
<span class="nc" id="L347">      return isLeafCall;</span>
    }
  }

  // **********************************************************************

  /** Subclass of JTree to override cell renderer and selection listener. */
<span class="nc" id="L354">  private class Gui4jJTree extends JTree {</span>

    private static final int ACTION_DOUBLE_CLICK = 1;
    private static final int ACTION_ON_SELECT = 2;

    protected final Gui4jCallBase gui4jCallBase;

<span class="nc" id="L361">    public Gui4jJTree(Gui4jTreeModel gui4jTreeModel) {</span>
<span class="nc" id="L362">      super(gui4jTreeModel);</span>
<span class="nc" id="L363">      gui4jCallBase = gui4jTreeModel.getGui4jCallBase();</span>

<span class="nc" id="L365">      getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);</span>
<span class="nc" id="L366">      setShowsRootHandles(true);</span>

<span class="nc" id="L368">      addMouseListener(</span>
<span class="nc" id="L369">          new MouseListener() {</span>
            public void mouseClicked(MouseEvent e) {
<span class="nc bnc" id="L371" title="All 2 branches missed.">              if (e.getClickCount() == 2) {</span>
<span class="nc" id="L372">                performNodeAction(ACTION_DOUBLE_CLICK);</span>
              }
<span class="nc" id="L374">            }</span>

<span class="nc" id="L376">            public void mousePressed(MouseEvent e) {}</span>

<span class="nc" id="L378">            public void mouseReleased(MouseEvent e) {}</span>

<span class="nc" id="L380">            public void mouseEntered(MouseEvent e) {}</span>

<span class="nc" id="L382">            public void mouseExited(MouseEvent e) {}</span>
          });

<span class="nc" id="L385">      Gui4jTreeSelectionListener listener =</span>
<span class="nc" id="L386">          new Gui4jTreeSelectionListener() {</span>
            // react on selection changes
            public void selectionChanged(TreeSelectionEvent e) {
<span class="nc" id="L389">              performNodeAction(ACTION_ON_SELECT);</span>

              {
                // call onSelect on Tree level
<span class="nc bnc" id="L393" title="All 2 branches missed.">                if (onSelectCallTree != null) {</span>
<span class="nc" id="L394">                  TreePath path = getSelectionPath();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                  Map params = new Gui4jMap1(PARAM_PATH, path == null ? null : path.getPath());</span>
<span class="nc" id="L396">                  getGui4j()</span>
<span class="nc" id="L397">                      .getGui4jThreadManager()</span>
<span class="nc" id="L398">                      .performWork(gui4jCallBase, onSelectCallTree, params);</span>
                }
              }
<span class="nc" id="L401">            }</span>
          };
<span class="nc" id="L403">      addTreeSelectionListener(listener);</span>
<span class="nc" id="L404">      addKeyListener(listener);</span>
<span class="nc" id="L405">      addFocusListener(listener);</span>

<span class="nc" id="L407">      setCellRenderer(new Gui4jTreeCellRenderer(gui4jCallBase));</span>
<span class="nc" id="L408">    }</span>

    public Gui4jTreeModel getGui4jTreeModel() {
<span class="nc" id="L411">      return (Gui4jTreeModel) getModel();</span>
    }

    protected void performNodeAction(int action) {
<span class="nc" id="L415">      Object node = getLastSelectedPathComponent();</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">      if (node != null) {</span>
<span class="nc" id="L417">        Gui4jTreeNode nodeInfo = (Gui4jTreeNode) nodeManager.get(node.getClass());</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (nodeInfo != null) {</span>
<span class="nc" id="L419">          Gui4jCall call = null;</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">          if (action == ACTION_DOUBLE_CLICK) {</span>
<span class="nc" id="L421">            call = nodeInfo.getOnDblClickCall();</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">          } else if (action == ACTION_ON_SELECT) {</span>
<span class="nc" id="L423">            call = nodeInfo.getOnSelectCall();</span>
          }
<span class="nc bnc" id="L425" title="All 2 branches missed.">          if (call != null) {</span>
<span class="nc" id="L426">            Map params = new Gui4jMap1(PARAM_ITEM, node);</span>
<span class="nc" id="L427">            getGui4j().getGui4jThreadManager().performWork(gui4jCallBase, call, params);</span>
          }
        }
      }
<span class="nc" id="L431">    }</span>

    public String convertValueToText(
        Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
<span class="nc bnc" id="L435" title="All 2 branches missed.">      if (value instanceof Gui4jTreeMessage) {</span>
<span class="nc" id="L436">        return ((Gui4jTreeMessage) value).getMessage();</span>
      }

<span class="nc" id="L439">      Gui4jTreeNode node = (Gui4jTreeNode) nodeManager.get(value.getClass());</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">      if (node == null) {</span>
<span class="nc" id="L441">        log.warn(&quot;Missing node definition for: &quot; + value);</span>
<span class="nc" id="L442">        return &quot;(missing node definition)&quot;;</span>
      }
<span class="nc" id="L444">      Gui4jCall valueCall = node.getValueCall();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">      assert valueCall != null; // value is a required attribute</span>

<span class="nc" id="L447">      Map params = new Gui4jMap1(PARAM_ITEM, value);</span>
<span class="nc" id="L448">      return (String) valueCall.getValue(gui4jCallBase, params, &quot;undefined&quot;);</span>
    }
  }

  // **********************************************************************

  /**
   * Subclass of TreeSelectionListener. Implements a simple strategy to solve the problem that a lot
   * of TreeSelectionEvents are generated and processed when the user keeps pressing the up and down
   * arrow keys. To work correctly, the same instance of this listener must be registered in three
   * ways with a tree, using {@link
   * JTree#addTreeSelectionListener(javax.swing.event.TreeSelectionListener)}, {@link
   * Component#addKeyListener(java.awt.event.KeyListener)} and {@link
   * Component#addFocusListener(java.awt.event.FocusListener)}. &lt;br&gt;
   * &lt;br&gt;
   * The problem this class solves is that a TreeSelectionEvent might trigger expensive operations
   * (e.g. loading detailed information for the newly selected tree node from a database). If the
   * user &quot;scrolls down&quot; by pressing the down arrow for a long time, the expensive operation is
   * performed for each visited node. This Listener blocks all TreeSelectionEvents while any key is
   * pressed. Only when a key is released is the most recent event passed to the actual event
   * handler.
   */
<span class="nc" id="L470">  private abstract static class Gui4jTreeSelectionListener</span>
      implements TreeSelectionListener, KeyListener, FocusListener {
<span class="nc" id="L472">    private boolean blockNotification = false;</span>
<span class="nc" id="L473">    private TreeSelectionEvent blockedEvent = null;</span>

    private void block() {
<span class="nc" id="L476">      blockNotification = true;</span>
<span class="nc" id="L477">    }</span>

    private void unblock() {
<span class="nc" id="L480">      blockNotification = false;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">      if (blockedEvent != null) {</span>
<span class="nc" id="L482">        selectionChanged(blockedEvent);</span>
<span class="nc" id="L483">        blockedEvent = null;</span>
      }
<span class="nc" id="L485">    }</span>

    /**
     * Subclasses must override this method instead of the usual {@link
     * TreeSelectionListener#valueChanged(javax.swing.event.TreeSelectionEvent)}.
     *
     * @param e
     */
    public abstract void selectionChanged(TreeSelectionEvent e);

    /**
     * Subclasses should not override this method (as is done with a normal TreeSelectionListener)
     * but {@link #selectionChanged(TreeSelectionEvent)} instead.
     *
     * @param e
     */
    public final void valueChanged(TreeSelectionEvent e) {
<span class="nc bnc" id="L502" title="All 2 branches missed.">      if (blockNotification) {</span>
<span class="nc" id="L503">        blockedEvent = e;</span>
      } else {
<span class="nc" id="L505">        blockedEvent = null;</span>
<span class="nc" id="L506">        selectionChanged(e);</span>
      }
<span class="nc" id="L508">    }</span>

    public void keyPressed(KeyEvent e) {
<span class="nc" id="L511">      block();</span>
<span class="nc" id="L512">    }</span>

    public void keyReleased(KeyEvent e) {
<span class="nc" id="L515">      unblock();</span>
<span class="nc" id="L516">    }</span>

    public void keyTyped(KeyEvent e) {
      // intentionally empty body
<span class="nc" id="L520">    }</span>

    public void focusGained(FocusEvent e) {
<span class="nc" id="L523">      unblock();</span>
<span class="nc" id="L524">    }</span>

    public void focusLost(FocusEvent e) {
<span class="nc" id="L527">      unblock();</span>
<span class="nc" id="L528">    }</span>
  }

  /** Cell Renderer */
  private class Gui4jTreeCellRenderer extends DefaultTreeCellRenderer {
    private final Gui4jCallBase gui4jCallBase;

<span class="nc" id="L535">    public Gui4jTreeCellRenderer(Gui4jCallBase gui4jCallBase) {</span>
<span class="nc" id="L536">      super();</span>
<span class="nc" id="L537">      setLeafIcon(null);</span>
<span class="nc" id="L538">      setOpenIcon(null);</span>
<span class="nc" id="L539">      setClosedIcon(null);</span>

<span class="nc" id="L541">      this.gui4jCallBase = gui4jCallBase;</span>
<span class="nc" id="L542">    }</span>

    public Component getTreeCellRendererComponent(
        JTree tree,
        Object value,
        boolean sel,
        boolean expanded,
        boolean leaf,
        int row,
        boolean pHasFocus) {
<span class="nc" id="L552">      super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, pHasFocus);</span>

<span class="nc" id="L554">      Gui4jTreeNode node = (Gui4jTreeNode) nodeManager.get(value.getClass());</span>
<span class="nc" id="L555">      int textPosition = TRAILING; // default</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">      if (node != null &amp;&amp; node.getIconCall() != null) {</span>
<span class="nc" id="L557">        Map params = new Gui4jMap1(PARAM_ITEM, value);</span>
<span class="nc" id="L558">        setIcon((Icon) (node.getIconCall().getValue(gui4jCallBase, params, null)));</span>
<span class="nc" id="L559">        textPosition = node.getTextPosition();</span>
      }

      // KKB, 16.6.03
      // Eigentlich sollte hier mit
      // setHorizontalTextPosition(textPosition) die Ausrichtung des
      // icons auf dem JLabel gesetzt werden. Das klappt auch, allerdings
      // geht
      // DefaultTreeCellRenderer.paint() davon aus, dass ein icon immer
      // vorne positioniert
      // ist. Dementsprechend wird der Hintergrund bei einem trailing icon
      // gezeichnet:
      // vorne scheint ein Teil des Knotentexts nicht selektiert zu sein,
      // w채hrend hinten
      // das icon optisch teil der selektion ist. Statt paint() komplett
      // selbst zu 체berschreiben,
      // wird hier ein netter workaround mit Hilfe der
      // ComponentOrientation verwendet.
<span class="nc" id="L577">      setComponentOrientation(</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">          textPosition == TRAILING</span>
<span class="nc" id="L579">              ? ComponentOrientation.LEFT_TO_RIGHT</span>
<span class="nc" id="L580">              : ComponentOrientation.RIGHT_TO_LEFT);</span>

<span class="nc" id="L582">      return this;</span>
    }
  }

  // **********************************************************************

  /**
   * Underlying model used by the &lt;code&gt;Gui4jJTree&lt;/code&gt;. Data is held only for caching reasons.
   * The model directly queries the object tree specified by the root attribute in the xml
   * definition.
   */
  private class Gui4jTreeModel implements TreeModel {
    private final Gui4jCallBase gui4jCallBase;
    protected final Gui4jSwingContainer gui4jSwingContainer;

    private final Set listeners; // Set(TreeModelListener)

    protected final List lazyChildrenMessage;

    private TreeSelectionModel selectionModel;
    private Gui4jTreeCoreModel coreModel;

<span class="nc" id="L604">    public Gui4jTreeModel(Gui4jCallBase gui4jCallBase, Gui4jSwingContainer gui4jSwingContainer) {</span>
<span class="nc" id="L605">      listeners = new HashSet();</span>
<span class="nc" id="L606">      this.gui4jCallBase = gui4jCallBase;</span>
<span class="nc" id="L607">      this.gui4jSwingContainer = gui4jSwingContainer;</span>

<span class="nc" id="L609">      coreModel = new Gui4jTreeCoreModel(this);</span>

<span class="nc" id="L611">      List list = Collections.EMPTY_LIST;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">      if (mLazyMessageCall != null) {</span>
<span class="nc" id="L613">        String lazyMessage = (String) mLazyMessageCall.getValueNoParams(gui4jCallBase, null);</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (lazyMessage != null) {</span>
<span class="nc" id="L615">          list = new ArrayList(1);</span>
<span class="nc" id="L616">          list.add(new Gui4jTreeMessage(lazyMessage));</span>
        }
      }
<span class="nc" id="L619">      lazyChildrenMessage = list;</span>
<span class="nc" id="L620">    }</span>

    public Gui4jTreeCoreModel getCoreModel() {
<span class="nc" id="L623">      return coreModel;</span>
    }

    public void setCoreModel(Gui4jTreeCoreModel newCoreModel) {
<span class="nc bnc" id="L627" title="All 2 branches missed.">      if (!SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L628">        log.warn(&quot;setCoreModel called from thead other than GUI thread, don't do that!&quot;);</span>
      }
<span class="nc" id="L630">      coreModel = newCoreModel;</span>
<span class="nc" id="L631">    }</span>

    public void setSelectionModel(TreeSelectionModel selectionModel) {
<span class="nc" id="L634">      this.selectionModel = selectionModel;</span>
<span class="nc" id="L635">    }</span>

    public void addTreeModelListener(TreeModelListener l) {
<span class="nc" id="L638">      listeners.add(l);</span>
<span class="nc" id="L639">    }</span>

    public Object getChild(Object parent, int index) {
<span class="nc" id="L642">      log.debug(&quot;getChild called with index &quot; + index + &quot; for parent: &quot; + parent);</span>
<span class="nc" id="L643">      return coreModel.getChildren(parent).get(index);</span>
    }

    public int getChildCount(Object parent) {
      // log.debug(&quot;getChildCount called for parent: &quot; + parent);
<span class="nc bnc" id="L648" title="All 2 branches missed.">      if (parent instanceof Gui4jTreeMessage) {</span>
<span class="nc" id="L649">        return 0;</span>
      }
<span class="nc" id="L651">      return coreModel.getChildren(parent).size();</span>
    }

    public int getIndexOfChild(Object parent, Object child) {
<span class="nc" id="L655">      log.debug(&quot;getIndexOfChild called (parent: &quot; + parent + &quot;, child: &quot; + child + &quot;)&quot;);</span>
<span class="nc" id="L656">      return coreModel.getIndexOfChild(parent, child, false);</span>
    }

    public Object getRoot() {
<span class="nc" id="L660">      return coreModel.displayRoot;</span>
    }

    public boolean isLeaf(Object parent) {
<span class="nc" id="L664">      return coreModel.isLeaf(parent);</span>
    }

    public void removeTreeModelListener(TreeModelListener l) {
<span class="nc" id="L668">      listeners.remove(l);</span>
<span class="nc" id="L669">    }</span>

<span class="nc" id="L671">    public void valueForPathChanged(TreePath path, Object newValue) {}</span>

    /**
     * Sets the root for the tree display.
     *
     * @param root
     */
    public void switchDisplayRoot(Object root) {
<span class="nc" id="L679">      coreModel.switchDisplayRoot(root);</span>
<span class="nc" id="L680">    }</span>

    /** Sets the root of the object graph as the root of the tree's display. */
    public void switchDisplayRootToMasterRoot() {
<span class="nc" id="L684">      coreModel.switchDisplayRootToMasterRoot();</span>
<span class="nc" id="L685">    }</span>

    /**
     * Invoke this method after the way the tree nodes are to be represented in the tree has
     * changed.
     */
    public void nodeTitlesChanged() {
<span class="nc" id="L692">      coreModel.nodeTitlesChanged();</span>
<span class="nc" id="L693">    }</span>

    public void notifyTreeStructureChanged(final TreePath treePath) {
<span class="nc bnc" id="L696" title="All 2 branches missed.">      if (treePath != null) {</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">        if (!SwingUtilities.isEventDispatchThread()) {</span>
          // KKB, MA, 23.7.04: Nicht vollst채ndig nachvollziehbares
          // Problem in FITS (Delete
          // Measurements)
          // &quot;behoben&quot; durch Verwendung von &quot;...andWait&quot; statt
          // &quot;...andContinue&quot;. Hm...., wissen
          // nicht
          // mehr, warum &quot;...andContinue&quot; urspr체nglich verwendet
          // wurde.
          // Gui4jThreadManager.executeInSwingThreadAndContinue(new
          // Runnable()
<span class="nc" id="L708">          Gui4jThreadManager.executeInSwingThreadAndWait(</span>
<span class="nc" id="L709">              new Runnable() {</span>
                public void run() {
<span class="nc" id="L711">                  log.debug(&quot;notifying tree after children have been loaded lazily&quot;);</span>
<span class="nc" id="L712">                  fireTreeStructureChanged(treePath);</span>
<span class="nc" id="L713">                }</span>
              });
        }
      }
<span class="nc" id="L717">    }</span>

    protected void fireTreeStructureChanged(TreePath path) {
<span class="nc" id="L720">      log.debug(&quot;fireTreeStructureChanged for path: &quot; + path);</span>

      // workaround: if the path contains only the root, then the
      // treeStructureChanged() call will clear the selection, so we
      // remember the selection and restore it later on
<span class="nc bnc" id="L725" title="All 2 branches missed.">      boolean retainRootSelection =</span>
<span class="nc bnc" id="L726" title="All 4 branches missed.">          path != null &amp;&amp; path.getPathCount() == 1 &amp;&amp; selectionModel.isPathSelected(path);</span>

<span class="nc" id="L728">      TreeModelEvent event = new TreeModelEvent(this, path);</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">      for (Iterator iter = listeners.iterator(); iter.hasNext(); ) {</span>
<span class="nc" id="L730">        TreeModelListener listener = (TreeModelListener) iter.next();</span>
<span class="nc" id="L731">        listener.treeStructureChanged(event);</span>
<span class="nc" id="L732">      }</span>

<span class="nc bnc" id="L734" title="All 2 branches missed.">      if (retainRootSelection) {</span>
<span class="nc" id="L735">        log.debug(&quot;retaining root selection after tree structure change&quot;);</span>
<span class="nc" id="L736">        selectionModel.setSelectionPath(path);</span>
      }
<span class="nc" id="L738">    }</span>

    public void fireTreeNodesChanged(TreePath path) {
<span class="nc" id="L741">      Object parent = path.getLastPathComponent();</span>
<span class="nc" id="L742">      List children = coreModel.getChildren(parent, true);</span>
      TreeModelEvent event;
<span class="nc bnc" id="L744" title="All 2 branches missed.">      if (children != null) {</span>
<span class="nc" id="L745">        int[] indices = new int[children.size()];</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">        for (int index = 0; index &lt; indices.length; index++) {</span>
<span class="nc" id="L747">          indices[index] = index;</span>
        }
<span class="nc" id="L749">        Object[] childrenArray = new Object[children.size()];</span>
<span class="nc" id="L750">        event = new TreeModelEvent(this, path, indices, children.toArray(childrenArray));</span>
<span class="nc" id="L751">      } else {</span>
<span class="nc" id="L752">        event = new TreeModelEvent(this, path);</span>
      }
<span class="nc bnc" id="L754" title="All 2 branches missed.">      for (Iterator iter = listeners.iterator(); iter.hasNext(); ) {</span>
<span class="nc" id="L755">        TreeModelListener listener = (TreeModelListener) iter.next();</span>
<span class="nc" id="L756">        listener.treeNodesChanged(event);</span>
<span class="nc" id="L757">      }</span>
<span class="nc" id="L758">    }</span>

    public Gui4jCallBase getGui4jCallBase() {
<span class="nc" id="L761">      return gui4jCallBase;</span>
    }

    /**
     * Returns a listener that reacts to &lt;code&gt;eventOccurred&lt;/code&gt; with a notification of the tree
     * to refresh its display.
     *
     * @return Gui4jEventListener
     */
    public Gui4jEventListener getRefreshListener() {
<span class="nc" id="L771">      return new Gui4jEventListener() {</span>
        public void eventOccured() {
<span class="nc" id="L773">          log.debug(&quot;Refresh of tree requested, delegating to GUI Thread.&quot;);</span>
<span class="nc" id="L774">          Gui4jThreadManager.executeInSwingThreadAndWait(</span>
<span class="nc" id="L775">              new Runnable() {</span>
                public void run() {
<span class="nc" id="L777">                  nodeTitlesChanged();</span>
<span class="nc" id="L778">                }</span>
              });
<span class="nc" id="L780">        }</span>
      };
    }
  }

  // ********************************************************************
  private final class Gui4jTreeCoreModel {
    private final Gui4jTreeModel model;

    private final Map childrenMap; // Object -&gt; List
    private final Object childrenMutex;
    private final Set childrenInProgress;

    private final Map leafMap; // Object -&gt; Boolean

    protected Object displayRoot; // root for tree gui to display
    private Object masterRoot; // root for object graph held by model

    public Gui4jTreeCoreModel(Gui4jTreeModel model) {
<span class="nc" id="L799">      this(model, false);</span>
<span class="nc" id="L800">    }</span>

<span class="nc" id="L802">    public Gui4jTreeCoreModel(Gui4jTreeModel model, boolean clone) {</span>
<span class="nc" id="L803">      this.model = model;</span>

<span class="nc bnc" id="L805" title="All 2 branches missed.">      if (clone) {</span>
<span class="nc" id="L806">        displayRoot = model.getCoreModel().displayRoot;</span>
<span class="nc" id="L807">        masterRoot = model.getCoreModel().masterRoot;</span>
<span class="nc" id="L808">        childrenMap = Collections.synchronizedMap(new HashMap(model.getCoreModel().childrenMap));</span>
<span class="nc" id="L809">        leafMap = Collections.synchronizedMap(new HashMap(model.getCoreModel().leafMap));</span>
      } else {
<span class="nc" id="L811">        displayRoot = null;</span>
<span class="nc" id="L812">        masterRoot = null;</span>
<span class="nc" id="L813">        childrenMap = Collections.synchronizedMap(new HashMap());</span>
<span class="nc" id="L814">        leafMap = Collections.synchronizedMap(new HashMap());</span>
      }

<span class="nc" id="L817">      childrenInProgress = Collections.synchronizedSet(new HashSet());</span>
<span class="nc" id="L818">      childrenMutex = new Object();</span>
<span class="nc" id="L819">    }</span>

    public Gui4jTreeModel getGui4jTreeModel() {
<span class="nc" id="L822">      return model;</span>
    }

    /**
     * Sets the root of the object graph held by this model
     *
     * @param root
     */
    public void setMasterRoot(Object root) {
<span class="nc" id="L831">      childrenMap.clear();</span>
<span class="nc" id="L832">      leafMap.clear();</span>
<span class="nc" id="L833">      this.masterRoot = root;</span>
<span class="nc" id="L834">      this.displayRoot = root;</span>
<span class="nc" id="L835">    }</span>

    /**
     * Sets the root for the tree display.
     *
     * @param root
     */
    public void switchDisplayRoot(Object root) {
<span class="nc" id="L843">      this.displayRoot = root;</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">      TreePath rootPath = (displayRoot == null) ? null : new TreePath(displayRoot);</span>
<span class="nc" id="L845">      model.fireTreeStructureChanged(rootPath);</span>
<span class="nc" id="L846">    }</span>

    /** Sets the root of the object graph as the root of the tree's display. */
    public void switchDisplayRootToMasterRoot() {
<span class="nc" id="L850">      switchDisplayRoot(masterRoot);</span>
<span class="nc" id="L851">    }</span>

    public boolean isLeaf(Object parent) {
      // log.debug(&quot;isLeaf called for node: &quot; + parent);
<span class="nc" id="L855">      Gui4jTreeNode nodeDef = (Gui4jTreeNode) nodeManager.get(parent.getClass());</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">      if (nodeDef == null) {</span>
<span class="nc" id="L857">        return true;</span>
      }

<span class="nc bnc" id="L860" title="All 4 branches missed.">      if (mLazy || nodeDef.lazy) {</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">        if (childrenMap.containsKey(parent)) {</span>
<span class="nc" id="L862">          return getChildren(parent).isEmpty();</span>
        } else {
<span class="nc bnc" id="L864" title="All 2 branches missed.">          if (nodeDef.getIsLeafCall() != null) {</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">            if (leafMap.containsKey(parent)) {</span>
<span class="nc" id="L866">              return ((Boolean) leafMap.get(parent)).booleanValue();</span>
            } else {
<span class="nc" id="L868">              log.warn(&quot;leafMap not filled for: &quot; + parent);</span>
<span class="nc" id="L869">              return true;</span>
            }
<span class="nc bnc" id="L871" title="All 2 branches missed.">          } else if (nodeDef.getChildrenCall() != null) {</span>
<span class="nc" id="L872">            return false;</span>
          } else {
<span class="nc" id="L874">            return true;</span>
          }
        }
      } else {
<span class="nc" id="L878">        return getChildren(parent).isEmpty();</span>
      }
    }

    public List getChildren(Object parent) {
<span class="nc" id="L883">      return getChildren(parent, false);</span>
    }

    protected List getChildren(Object parent, boolean restrictToCache) {
<span class="nc" id="L887">      return getChildren(parent, restrictToCache, true);</span>
    }

    protected List getChildren(Object parent, boolean restrictToCache, boolean allowLazy) {
<span class="nc bnc" id="L891" title="All 2 branches missed.">      if (parent instanceof Gui4jTreeMessage) {</span>
<span class="nc" id="L892">        return Collections.EMPTY_LIST;</span>
      }

<span class="nc" id="L895">      List children = (List) childrenMap.get(parent);</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">      if (restrictToCache) {</span>
<span class="nc" id="L897">        return children;</span>
      }
<span class="nc bnc" id="L899" title="All 2 branches missed.">      if (children == null) {</span>
<span class="nc" id="L900">        Gui4jTreeNode nodeDef = (Gui4jTreeNode) nodeManager.get(parent.getClass());</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if (nodeDef == null) {</span>
<span class="nc" id="L902">          log.warn(&quot;Missing node definition for: &quot; + parent);</span>
<span class="nc" id="L903">          children = Collections.EMPTY_LIST;</span>
<span class="nc bnc" id="L904" title="All 6 branches missed.">        } else if (allowLazy &amp;&amp; (mLazy || nodeDef.lazy)) {</span>
<span class="nc" id="L905">          children = model.lazyChildrenMessage;</span>

<span class="nc" id="L907">          synchronized (childrenInProgress) {</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (childrenInProgress.contains(parent)) {</span>
<span class="nc" id="L909">              return children;</span>
            } else {
              // double check to avoid multiple retrievals
<span class="nc" id="L912">              List cache = (List) childrenMap.get(parent);</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">              if (cache != null) {</span>
<span class="nc" id="L914">                return cache;</span>
              }

<span class="nc" id="L917">              childrenInProgress.add(parent);</span>
            }
<span class="nc" id="L919">          }</span>

<span class="nc" id="L921">          Gui4jChildrenRetriever retriever = new Gui4jChildrenRetriever(this, nodeDef, parent);</span>
<span class="nc" id="L922">          retriever.run(true);</span>

<span class="nc" id="L924">        } else {</span>
<span class="nc" id="L925">          children = retrieveChildren(nodeDef, parent);</span>
        }
      }
<span class="nc" id="L928">      return children;</span>
    }

    protected int getIndexOfChild(Object parent, Object child, boolean restrictToCache) {
<span class="nc bnc" id="L932" title="All 4 branches missed.">      if (parent == null || child == null) {</span>
<span class="nc" id="L933">        return -1;</span>
      }

<span class="nc" id="L936">      List children = getChildren(parent, restrictToCache, false);</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">      if (children != null) {</span>
<span class="nc" id="L938">        return children.indexOf(child);</span>
      } else {
<span class="nc" id="L940">        return -1;</span>
      }
    }

    /**
     * Invoke this method after the way the tree nodes are to be represented in the tree has
     * changed.
     */
    public void nodeTitlesChanged() {
      // notify the tree of changed node titles
<span class="nc bnc" id="L950" title="All 2 branches missed.">      if (displayRoot != null) {</span>
<span class="nc" id="L951">        nodeTitlesChanged(new TreePath(displayRoot));</span>
      }
<span class="nc" id="L953">    }</span>

    /**
     * Notifies the tree of changes to all nodes from this path's root on.
     *
     * @param path the node under which all node representations (potentially) have changed.
     */
    private void nodeTitlesChanged(TreePath path) {
<span class="nc" id="L961">      log.debug(&quot;nodeTitlesChanged called for path: &quot; + path);</span>
<span class="nc" id="L962">      model.fireTreeNodesChanged(path);</span>

      // recurse over all children that have been requested
      // before and therefore are in the cache
<span class="nc" id="L966">      Object parent = path.getLastPathComponent();</span>
<span class="nc" id="L967">      List children = getChildren(parent, true);</span>

<span class="nc bnc" id="L969" title="All 2 branches missed.">      if (children != null) {</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">        for (int index = 0; index &lt; children.size(); index++) {</span>
<span class="nc" id="L971">          Object child = children.get(index);</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">          if (childrenMap.containsKey(child)) {</span>
<span class="nc" id="L973">            TreePath childPath = path.pathByAddingChild(children.get(index));</span>
<span class="nc" id="L974">            nodeTitlesChanged(childPath);</span>
          }
        }
      }
<span class="nc" id="L978">    }</span>

    protected List retrieveChildren(Gui4jTreeNode nodeDef, Object parent) {
<span class="nc" id="L981">      log.debug(&quot;retrieveChildren called for parent: &quot; + parent);</span>

      List children;
<span class="nc" id="L984">      synchronized (childrenMutex) {</span>
        // double check, maybe we waited because another thread
        // retrieved &quot;our&quot; children
<span class="nc" id="L987">        children = (List) childrenMap.get(parent);</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">        if (children != null) {</span>
<span class="nc" id="L989">          log.debug(&quot;children for parent have already been retrieved: &quot; + parent);</span>
<span class="nc" id="L990">          return children;</span>
        }

<span class="nc" id="L993">        log.debug(&quot;retrieveChildren: will retrieve children for: &quot; + parent);</span>
<span class="nc" id="L994">        Gui4jCall childrenCall = nodeDef.getChildrenCall();</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if (childrenCall != null) {</span>
<span class="nc" id="L996">          Map params = new Gui4jMap1(PARAM_ITEM, parent);</span>
<span class="nc" id="L997">          children = (List) childrenCall.getValue(model.getGui4jCallBase(), params, null);</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">          if (!mUseOriginalCollection) {</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">            children = children == null ? Collections.EMPTY_LIST : new ArrayList(children);</span>
          }
        }
<span class="nc bnc" id="L1002" title="All 2 branches missed.">        if (children == null) {</span>
<span class="nc" id="L1003">          children = Collections.EMPTY_LIST;</span>
        }
        // Important: childrenMap.put() must not be called anywhere else
<span class="nc" id="L1006">        childrenMap.put(parent, children);</span>

<span class="nc bnc" id="L1008" title="All 2 branches missed.">        for (Iterator iter = children.iterator(); iter.hasNext(); ) {</span>
<span class="nc" id="L1009">          Object child = iter.next();</span>
<span class="nc" id="L1010">          Gui4jTreeNode childDef = (Gui4jTreeNode) nodeManager.get(child.getClass());</span>
<span class="nc bnc" id="L1011" title="All 8 branches missed.">          if (childDef != null &amp;&amp; (mLazy || childDef.lazy) &amp;&amp; childDef.getIsLeafCall() != null) {</span>
<span class="nc" id="L1012">            retrieveLeaf(childDef, child);</span>
          }
<span class="nc" id="L1014">        }</span>

<span class="nc" id="L1016">        childrenInProgress.remove(parent);</span>
<span class="nc" id="L1017">      }</span>

<span class="nc" id="L1019">      return children;</span>
    }

    protected void retrieveLeaf(Gui4jTreeNode nodeDef, Object node) {
<span class="nc" id="L1023">      Boolean isLeaf = (Boolean) leafMap.get(node);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">      if (isLeaf != null) {</span>
<span class="nc" id="L1025">        log.warn(&quot;leaf info already in map for node: &quot; + node);</span>
<span class="nc" id="L1026">        return;</span>
      }

<span class="nc" id="L1029">      log.debug(&quot;retrieveLeaf: will retrieve isLeaf for: &quot; + node);</span>
<span class="nc" id="L1030">      Gui4jCall isLeafCall = nodeDef.getIsLeafCall();</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">      if (isLeafCall == null) {</span>
<span class="nc" id="L1032">        log.warn(&quot;retrieveLeaf called but isLeafCall not defined.&quot;);</span>
<span class="nc" id="L1033">        return;</span>
      }

<span class="nc" id="L1036">      Map params = new Gui4jMap1(PARAM_ITEM, node);</span>
<span class="nc" id="L1037">      isLeaf = (Boolean) isLeafCall.getValue(model.getGui4jCallBase(), params, null);</span>

<span class="nc bnc" id="L1039" title="All 2 branches missed.">      if (isLeaf == null) {</span>
<span class="nc" id="L1040">        log.warn(&quot;retrieveLeaf: isLeaf call returns null for: &quot; + node);</span>
<span class="nc" id="L1041">        return;</span>
      }
<span class="nc" id="L1043">      leafMap.put(node, isLeaf); // Important: leafMap.put() must not be</span>
      // called anywhere else

<span class="nc" id="L1046">    }</span>

    /**
     * Return a TreePath representing the path from the root to the given node. The node is found by
     * doing a depth first search from the root of the tree. If you want to avoid this search (e.g.
     * for performance reasons) use {@link #getPath(Object[])}instead.
     *
     * @param node
     * @return a TreePath or &lt;code&gt;null&lt;/code&gt; if the node is not found in the tree
     */
    public final TreePath getPath(Object node) {
<span class="nc" id="L1057">      return getPath(node, false);</span>
    }

    public final TreePath getPath(Object node, boolean restrictToCache) {
<span class="nc bnc" id="L1061" title="All 4 branches missed.">      if (node == null || displayRoot == null) {</span>
<span class="nc" id="L1062">        return null;</span>
      }

<span class="nc" id="L1065">      TreePath rootPath = new TreePath(displayRoot);</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">      if (node.equals(displayRoot)) {</span>
<span class="nc" id="L1067">        return rootPath;</span>
      }
<span class="nc" id="L1069">      return getPath(rootPath, node, restrictToCache);</span>
    }

    public final TreePath getPath(TreePath pathSoFar, Object node, boolean restrictToCache) {
<span class="nc" id="L1073">      Object potentialParent = pathSoFar.getLastPathComponent();</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">      if (getIndexOfChild(potentialParent, node, restrictToCache) != -1) {</span>
<span class="nc" id="L1075">        return pathSoFar.pathByAddingChild(node);</span>
      } else {
<span class="nc" id="L1077">        List children = getChildren(potentialParent, restrictToCache);</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">        if (children != null) {</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">          for (int i = 0; i &lt; children.size(); i++) {</span>
<span class="nc" id="L1080">            Object candidate = children.get(i);</span>
<span class="nc" id="L1081">            TreePath attempt =</span>
<span class="nc" id="L1082">                getPath(pathSoFar.pathByAddingChild(candidate), node, restrictToCache);</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            if (attempt != null) {</span>
<span class="nc" id="L1084">              return attempt;</span>
            }
          }
        }
<span class="nc" id="L1088">        return null;</span>
      }
    }

    public final TreePath getPath(Object[] path) {
<span class="nc" id="L1093">      Object root = displayRoot;</span>
<span class="nc bnc" id="L1094" title="All 8 branches missed.">      if (path == null || path.length == 0 || root == null || !(path[0].equals(root))) {</span>
<span class="nc" id="L1095">        log.debug(&quot;equals Vergleich: &quot; + path[0].equals(root));</span>
<span class="nc" id="L1096">        log.debug(</span>
            &quot;getPath: object array is empty or first element is not the tree root. first array element: &quot;
                + path[0]
                + &quot;, root: &quot;
                + root);
<span class="nc" id="L1101">        return null;</span>
      }

<span class="nc" id="L1104">      TreePath rootPath = new TreePath(root);</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">      if (path.length == 1) {</span>
<span class="nc" id="L1106">        return rootPath;</span>
      } else {
<span class="nc" id="L1108">        return getPath(rootPath, path, 1);</span>
      }
    }

    private TreePath getPath(TreePath pathSoFar, Object[] path, int offset) {

<span class="nc" id="L1114">      Object potentialParent = pathSoFar.getLastPathComponent();</span>
<span class="nc" id="L1115">      Object node = path[offset];</span>

      int nextOffset;
      TreePath treePath;

<span class="nc bnc" id="L1120" title="All 2 branches missed.">      if (node == null) {</span>
        // we interpret a null as a &quot;wildcard&quot; and will try to get the
        // next
        // element using a complete search
<span class="nc bnc" id="L1124" title="All 2 branches missed.">        if (path.length &lt;= offset + 1) {</span>
<span class="nc" id="L1125">          log.debug(</span>
              &quot;getPath: found null as 'wildcard', but as last path element which doesn't make sense.&quot;);
<span class="nc" id="L1127">          return null;</span>
        }
<span class="nc" id="L1129">        node = path[offset + 1];</span>
<span class="nc" id="L1130">        log.debug(</span>
            &quot;getPath: interpeting null in search path as 'wildcard', using node search to find: &quot;
                + node);
<span class="nc" id="L1133">        treePath = getPath(pathSoFar, node, false);</span>
<span class="nc" id="L1134">        nextOffset = offset + 2;</span>
      } else {
<span class="nc bnc" id="L1136" title="All 2 branches missed.">        if (getIndexOfChild(potentialParent, node, false) == -1) {</span>
<span class="nc" id="L1137">          log.debug(&quot;getPath: child not found for parent: &quot; + potentialParent + &quot;, child: &quot; + node);</span>
<span class="nc" id="L1138">          return null;</span>
        }

<span class="nc" id="L1141">        treePath = pathSoFar.pathByAddingChild(node);</span>
<span class="nc" id="L1142">        nextOffset = offset + 1;</span>
      }

<span class="nc bnc" id="L1145" title="All 2 branches missed.">      if (path.length &gt; nextOffset) {</span>
<span class="nc" id="L1146">        return getPath(treePath, path, nextOffset);</span>
      } else {
<span class="nc" id="L1148">        return treePath;</span>
      }
    }

    public void removeCacheForSubtree(Object[] path) {
<span class="nc bnc" id="L1153" title="All 4 branches missed.">      if (path == null || path.length == 0) {</span>
<span class="nc" id="L1154">        log.warn(&quot;removePath called with null or empty path: &quot; + path);</span>
<span class="nc" id="L1155">        return;</span>
      }

<span class="nc" id="L1158">      Object subtreeRoot = path[path.length - 1];</span>
<span class="nc" id="L1159">      removeCacheForSubtree(subtreeRoot);</span>

<span class="nc" id="L1161">      Gui4jTreeNode nodeDef = (Gui4jTreeNode) nodeManager.get(subtreeRoot.getClass());</span>
<span class="nc bnc" id="L1162" title="All 6 branches missed.">      if ((mLazy || nodeDef.lazy) &amp;&amp; nodeDef.getIsLeafCall() != null) {</span>
<span class="nc" id="L1163">        retrieveLeaf(nodeDef, subtreeRoot);</span>
      }
<span class="nc" id="L1165">    }</span>

    protected void removeCacheForSubtree(Object node) {
<span class="nc" id="L1168">      leafMap.remove(node);</span>
<span class="nc" id="L1169">      List children = (List) childrenMap.remove(node);</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">      if (children != null) {</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">        for (Iterator iter = children.iterator(); iter.hasNext(); ) {</span>
<span class="nc" id="L1172">          Object child = iter.next();</span>
<span class="nc" id="L1173">          removeCacheForSubtree(child);</span>
<span class="nc" id="L1174">        }</span>
      }
<span class="nc" id="L1176">    }</span>
  }

  // **********************************************************************

  private abstract class Gui4jTreeWorker implements Gui4jGetValue {
    protected final Gui4jTreeModel treeModel;

<span class="nc" id="L1184">    protected Gui4jTreeWorker(Gui4jTreeModel model) {</span>
<span class="nc" id="L1185">      treeModel = model;</span>
<span class="nc" id="L1186">    }</span>

    public void run(boolean separateThread) {
<span class="nc bnc" id="L1189" title="All 2 branches missed.">      if (separateThread) {</span>
<span class="nc" id="L1190">        treeModel.gui4jSwingContainer.setBusy(true);</span>
<span class="nc" id="L1191">        getGui4j().getGui4jThreadManager().performWork(treeModel.getGui4jCallBase(), this, null);</span>
      } else {
<span class="nc" id="L1193">        work();</span>
      }
<span class="nc" id="L1195">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see de.bea.gui4j.call.Gui4jGetValue#getValue(de.bea.gui4j.Gui4jCallBase,
     *      java.util.Map, java.lang.Object)
     */
    public final Object getValue(Gui4jCallBase gui4jCallBase, Map paramMap, Object defaultValue) {
      try {
<span class="nc" id="L1205">        work();</span>
<span class="nc" id="L1206">        return null;</span>
      } finally {
<span class="nc" id="L1208">        treeModel.gui4jSwingContainer.setBusy(false);</span>
      }
    }

    /*
     * (non-Javadoc)
     *
     * @see de.bea.gui4j.call.Gui4jGetValue#getValueNoErrorChecking(de.bea.gui4j.Gui4jCallBase,
     *      java.util.Map, java.lang.Object)
     */
    public final Object getValueNoErrorChecking(
        Gui4jCallBase gui4jCallBase, Map paramMap, Gui4jComponentInstance componentInstance) {
<span class="nc" id="L1220">      return getValue(gui4jCallBase, paramMap, null);</span>
    }

    protected abstract void work();
  }

  // ***************************************************************************************

  private final class Gui4jChildrenRetriever extends Gui4jTreeWorker {
    private final Gui4jTreeCoreModel coreModel;
    private final Gui4jTreeNode nodeDef;
    private final Object parent;

<span class="nc" id="L1233">    Gui4jChildrenRetriever(Gui4jTreeCoreModel coreModel, Gui4jTreeNode nodeDef, Object parent) {</span>
<span class="nc" id="L1234">      super(coreModel.getGui4jTreeModel());</span>
<span class="nc" id="L1235">      this.coreModel = coreModel;</span>
<span class="nc" id="L1236">      this.nodeDef = nodeDef;</span>
<span class="nc" id="L1237">      this.parent = parent;</span>
<span class="nc" id="L1238">    }</span>

    protected void work() {
<span class="nc" id="L1241">      log.debug(&quot;Gui4jChildrenRetriever starts working...&quot;);</span>
<span class="nc" id="L1242">      coreModel.retrieveChildren(nodeDef, parent);</span>

<span class="nc" id="L1244">      TreePath treePath = coreModel.getPath(parent, true);</span>
<span class="nc" id="L1245">      treeModel.notifyTreeStructureChanged(treePath);</span>
<span class="nc" id="L1246">    }</span>

    public String toString() {
<span class="nc" id="L1249">      return &quot;Gui4jTree: retrieving children for: &quot; + parent;</span>
    }
  }

  // *********************************************************************************************

<span class="nc" id="L1255">  private final class Gui4jTreeSelector extends Gui4jTreeWorker {</span>
    protected final JTree mTree;
    private final Object[] mPath;
    private final Object mNode;

<span class="nc" id="L1260">    private Gui4jTreeSelector(JTree tree, Object[] path, Object node) {</span>
<span class="nc" id="L1261">      super((Gui4jTreeModel) tree.getModel());</span>
<span class="nc" id="L1262">      this.mTree = tree;</span>
<span class="nc" id="L1263">      this.mPath = path;</span>
<span class="nc" id="L1264">      this.mNode = node;</span>
<span class="nc" id="L1265">    }</span>

    Gui4jTreeSelector(JTree tree, Object[] path) {
<span class="nc" id="L1268">      this(tree, path, null);</span>
<span class="nc" id="L1269">    }</span>

    Gui4jTreeSelector(JTree tree, Object node) {
<span class="nc" id="L1272">      this(tree, null, node);</span>
<span class="nc" id="L1273">    }</span>

    public void work() {
<span class="nc" id="L1276">      log.debug(&quot;Gui4jTreeSelector starts working...&quot;);</span>

<span class="nc bnc" id="L1278" title="All 4 branches missed.">      assert mPath != null || mNode != null;</span>

      final TreePath treePath;

      // prefer specified path over specified node
<span class="nc bnc" id="L1283" title="All 2 branches missed.">      if (mPath != null) {</span>
<span class="nc" id="L1284">        treePath = treeModel.getCoreModel().getPath(mPath);</span>
      } else {
<span class="nc" id="L1286">        treePath = treeModel.getCoreModel().getPath(mNode);</span>
      }
<span class="nc bnc" id="L1288" title="All 2 branches missed.">      if (treePath != null) {</span>
<span class="nc" id="L1289">        log.debug(&quot;Delegating to GUI thread: tree selection to path: &quot; + treePath);</span>
<span class="nc" id="L1290">        Gui4jThreadManager.executeInSwingThreadAndWait(</span>
<span class="nc" id="L1291">            new Runnable() {</span>
              public void run() {
<span class="nc" id="L1293">                log.debug(&quot;TreeSelector: telling tree to select (and scroll to) path: &quot; + treePath);</span>
<span class="nc" id="L1294">                mTree.setSelectionPath(treePath);</span>
<span class="nc" id="L1295">                mTree.scrollPathToVisible(treePath);</span>
<span class="nc" id="L1296">              }</span>
            });
      }
<span class="nc" id="L1299">    }</span>

    public String toString() {
<span class="nc" id="L1302">      return &quot;Gui4jTree: selecting path: &quot; + Utils.arrayToString(mPath) + &quot; or node: &quot; + mNode;</span>
    }
  }

  // *************************************************************************

  private final class Gui4jTreeRootChanger extends Gui4jTreeWorker {

    protected final Gui4jJTree tree;
    protected final Object root;
    private final Object[] pathToSelect;
    private final Object nodeToSelect;

    public Gui4jTreeRootChanger(
<span class="nc" id="L1316">        Gui4jJTree tree, Object root, Object[] pathToSelect, Object nodeToSelect) {</span>
<span class="nc" id="L1317">      super(tree.getGui4jTreeModel());</span>
<span class="nc" id="L1318">      this.tree = tree;</span>
<span class="nc" id="L1319">      this.root = root;</span>
<span class="nc" id="L1320">      this.pathToSelect = pathToSelect;</span>
<span class="nc" id="L1321">      this.nodeToSelect = nodeToSelect;</span>
<span class="nc" id="L1322">    }</span>

    protected void work() {
<span class="nc" id="L1325">      log.debug(&quot;Gui4jTreeRootChanger starting...&quot;);</span>

<span class="nc" id="L1327">      final Gui4jTreeCoreModel coreModel = new Gui4jTreeCoreModel(treeModel);</span>

<span class="nc" id="L1329">      coreModel.setMasterRoot(root); // this must not and will not notify</span>
      // the tree

<span class="nc" id="L1332">      TreePath treePath = null;</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">      if (pathToSelect != null) {</span>
<span class="nc" id="L1334">        treePath = coreModel.getPath(pathToSelect);</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">      } else if (nodeToSelect != null) {</span>
<span class="nc" id="L1336">        treePath = coreModel.getPath(nodeToSelect);</span>
      }

<span class="nc" id="L1339">      final TreePath selection = treePath;</span>
<span class="nc bnc" id="L1340" title="All 2 branches missed.">      final TreePath rootPath = (root == null) ? null : new TreePath(root);</span>
<span class="nc" id="L1341">      Gui4jThreadManager.executeInSwingThreadAndWait(</span>
<span class="nc" id="L1342">          new Runnable() {</span>
            public void run() {
<span class="nc" id="L1344">              log.debug(&quot;switching core tree model to: &quot; + root);</span>
<span class="nc" id="L1345">              treeModel.setCoreModel(coreModel); // switch over to new</span>
              // core model

              // notify tree of root change and desired selection
<span class="nc" id="L1349">              treeModel.fireTreeStructureChanged(rootPath);</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">              if (selection != null) {</span>
<span class="nc" id="L1351">                log.debug(&quot;RootChanger: telling tree to select (and scroll to) path: &quot; + selection);</span>
<span class="nc" id="L1352">                tree.setSelectionPath(selection);</span>
<span class="nc" id="L1353">                tree.scrollPathToVisible(selection);</span>
              }
<span class="nc bnc" id="L1355" title="All 2 branches missed.">              if (mInitiallyExpand) {</span>
<span class="nc" id="L1356">                Gui4jTreeExpander treeExpander =</span>
                    new Gui4jTreeExpander(tree, root, COMMAND_EXPAND_ALL);
<span class="nc" id="L1358">                treeExpander.work();</span>
              }
<span class="nc" id="L1360">            }</span>
          });
<span class="nc" id="L1362">    }</span>

    public String toString() {
<span class="nc" id="L1365">      return &quot;Gui4jTree: setting new root: &quot; + root;</span>
    }
  }

  // *************************************************************************

  private final class Gui4jTreeReloader extends Gui4jTreeWorker {

    protected final Gui4jJTree tree;
    private final Object[] reloadPath;
    private final Object[] pathToSelect;
    private final Object nodeToSelect;

    public Gui4jTreeReloader(
<span class="nc" id="L1379">        Gui4jJTree tree, Object[] reloadPath, Object[] pathToSelect, Object nodeToSelect) {</span>
<span class="nc" id="L1380">      super(tree.getGui4jTreeModel());</span>
<span class="nc" id="L1381">      this.tree = tree;</span>
<span class="nc" id="L1382">      this.reloadPath = reloadPath;</span>
<span class="nc" id="L1383">      this.pathToSelect = pathToSelect;</span>
<span class="nc" id="L1384">      this.nodeToSelect = nodeToSelect;</span>
<span class="nc" id="L1385">    }</span>

    protected void work() {
<span class="nc" id="L1388">      log.debug(&quot;Gui4jTreeReloader starting...&quot;);</span>

<span class="nc bnc" id="L1390" title="All 4 branches missed.">      if (reloadPath == null || reloadPath.length == 0) {</span>
<span class="nc" id="L1391">        log.debug(&quot;reloadPath null or empty, not reloading anything&quot;);</span>
<span class="nc" id="L1392">        return;</span>
      }

      // create copy of current core model
<span class="nc" id="L1396">      final Gui4jTreeCoreModel coreModel = new Gui4jTreeCoreModel(treeModel, true);</span>

      // remove cache information for whole subtree
<span class="nc" id="L1399">      Object subtreeRoot = reloadPath[reloadPath.length - 1];</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">      if (subtreeRoot == null) {</span>
<span class="nc" id="L1401">        log.warn(&quot;Tried to reload path with null as root of subtree.&quot;);</span>
<span class="nc" id="L1402">        return;</span>
      }
<span class="nc" id="L1404">      coreModel.removeCacheForSubtree(subtreeRoot);</span>

      // refresh isLeaf for root of subtree (if necessary)
<span class="nc" id="L1407">      Gui4jTreeNode nodeDef = (Gui4jTreeNode) nodeManager.get(subtreeRoot.getClass());</span>
<span class="nc bnc" id="L1408" title="All 6 branches missed.">      if ((mLazy || nodeDef.lazy) &amp;&amp; nodeDef.getIsLeafCall() != null) {</span>
<span class="nc" id="L1409">        coreModel.retrieveLeaf(nodeDef, subtreeRoot);</span>
      }

      // get TreePath for tree structure notification
<span class="nc" id="L1413">      final TreePath reloadTreePath = coreModel.getPath(reloadPath);</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">      if (reloadTreePath == null) {</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1416">          log.debug(&quot;Provided path is not part of tree: &quot; + Arrays.asList(reloadPath));</span>
        }
<span class="nc" id="L1418">        return;</span>
      }

      // get TreePath for tree selection
<span class="nc" id="L1422">      TreePath treePath = null;</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">      if (pathToSelect != null) {</span>
<span class="nc" id="L1424">        treePath = coreModel.getPath(pathToSelect);</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">      } else if (nodeToSelect != null) {</span>
        // search for node only under the reloaded path, not the whole
        // tree
<span class="nc bnc" id="L1428" title="All 2 branches missed.">        if (nodeToSelect.equals(reloadTreePath.getLastPathComponent())) {</span>
<span class="nc" id="L1429">          treePath = reloadTreePath;</span>
        } else {
<span class="nc" id="L1431">          treePath = coreModel.getPath(reloadTreePath, nodeToSelect, false);</span>
        }
      }
<span class="nc" id="L1434">      final TreePath selectionPath = treePath;</span>

      // switch core model and notify tree in GUI thread
<span class="nc" id="L1437">      Gui4jThreadManager.executeInSwingThreadAndWait(</span>
<span class="nc" id="L1438">          new Runnable() {</span>
            public void run() {
<span class="nc" id="L1440">              log.debug(&quot;switching core tree model after 'reloading': &quot; + reloadTreePath);</span>
<span class="nc" id="L1441">              treeModel.setCoreModel(coreModel); // switch over to new</span>
              // core model

              // notify tree of root change and desired selection
<span class="nc" id="L1445">              treeModel.fireTreeStructureChanged(reloadTreePath);</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">              if (selectionPath != null) {</span>
<span class="nc" id="L1447">                tree.setSelectionPath(selectionPath);</span>
<span class="nc" id="L1448">                tree.scrollPathToVisible(selectionPath);</span>
              }
<span class="nc" id="L1450">            }</span>
          });
<span class="nc" id="L1452">    }</span>

    public String toString() {
<span class="nc" id="L1455">      return &quot;Gui4jTree: reloading path: &quot; + Utils.arrayToString(reloadPath);</span>
    }
  }

  // *************************************************************************

  private final class Gui4jTreeExpander extends Gui4jTreeWorker {
    protected final Gui4jJTree tree;
    private final Object node;
    private final int command;

<span class="nc" id="L1466">    public Gui4jTreeExpander(Gui4jJTree tree, Object node, int command) {</span>
<span class="nc" id="L1467">      super(tree.getGui4jTreeModel());</span>
<span class="nc" id="L1468">      this.tree = tree;</span>
<span class="nc" id="L1469">      this.node = node;</span>
<span class="nc" id="L1470">      this.command = command;</span>
<span class="nc" id="L1471">    }</span>

    protected void work() {
<span class="nc" id="L1474">      TreePath path = treeModel.getCoreModel().getPath(node, true);</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">      if (path == null) {</span>
<span class="nc" id="L1476">        return;</span>
      }

<span class="nc bnc" id="L1479" title="All 5 branches missed.">      switch (command) {</span>
        case COMMAND_EXPAND_ALL:
          {
<span class="nc" id="L1482">            log.debug(&quot;expandAll: will expand everything under: &quot; + path);</span>
<span class="nc" id="L1483">            expandAll(path);</span>
          }
<span class="nc" id="L1485">          break;</span>

        case COMMAND_EXPAND:
          {
<span class="nc" id="L1489">            expandPath(path);</span>
          }
<span class="nc" id="L1491">          break;</span>

        case COMMAND_COLLAPSE_ALL:
          {
<span class="nc" id="L1495">            collapseAll(path);</span>
          }
<span class="nc" id="L1497">          break;</span>

        case COMMAND_COLLAPSE:
          {
<span class="nc" id="L1501">            collapsePath(path);</span>
          }
<span class="nc" id="L1503">          break;</span>

        default:
<span class="nc" id="L1506">          log.warn(&quot;Unknown Gui4jTreeExpander command: &quot; + command);</span>
      }
<span class="nc" id="L1508">    }</span>

    private void expandAll(final TreePath path) {
      // recurse over subtree and make all leafs visible
<span class="nc" id="L1512">      Object lnode = path.getLastPathComponent();</span>
<span class="nc" id="L1513">      List children = treeModel.getCoreModel().getChildren(lnode, false, false);</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">      if (children.isEmpty()) {</span>
<span class="nc" id="L1515">        makeNodeVisible(path);</span>
      } else {
<span class="nc bnc" id="L1517" title="All 2 branches missed.">        for (Iterator it = children.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1518">          Object child = it.next();</span>
<span class="nc" id="L1519">          expandAll(path.pathByAddingChild(child));</span>
<span class="nc" id="L1520">        }</span>
      }
<span class="nc" id="L1522">    }</span>

    private void collapseAll(final TreePath path) {
<span class="nc bnc" id="L1525" title="All 2 branches missed.">      if (tree.isExpanded(path)) {</span>
        // recurse over children
<span class="nc" id="L1527">        Object lnode = path.getLastPathComponent();</span>
<span class="nc" id="L1528">        List children = treeModel.getCoreModel().getChildren(lnode, true, false);</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">        if (children != null) {</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">          for (Iterator it = children.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1531">            Object child = it.next();</span>
<span class="nc" id="L1532">            collapseAll(path.pathByAddingChild(child));</span>
<span class="nc" id="L1533">          }</span>
        }

        // collapse current node
<span class="nc" id="L1537">        collapsePath(path);</span>
      }
<span class="nc" id="L1539">    }</span>

    private void expandPath(final TreePath path) {
<span class="nc" id="L1542">      Gui4jThreadManager.executeInSwingThreadAndContinue(</span>
<span class="nc" id="L1543">          new Runnable() {</span>
            public void run() {
<span class="nc" id="L1545">              tree.expandPath(path);</span>
<span class="nc" id="L1546">            }</span>
          });
<span class="nc" id="L1548">    }</span>

    private void makeNodeVisible(final TreePath path) {
<span class="nc" id="L1551">      Gui4jThreadManager.executeInSwingThreadAndContinue(</span>
<span class="nc" id="L1552">          new Runnable() {</span>
            public void run() {
<span class="nc" id="L1554">              tree.makeVisible(path);</span>
<span class="nc" id="L1555">            }</span>
          });
<span class="nc" id="L1557">    }</span>

    private void collapsePath(final TreePath path) {
<span class="nc" id="L1560">      Gui4jThreadManager.executeInSwingThreadAndContinue(</span>
<span class="nc" id="L1561">          new Runnable() {</span>
            public void run() {
<span class="nc" id="L1563">              tree.collapsePath(path);</span>
<span class="nc" id="L1564">            }</span>
          });
<span class="nc" id="L1566">    }</span>

    public String toString() {
<span class="nc" id="L1569">      return &quot;Gui4jTree: expanding or collapsing node: &quot; + node;</span>
    }
  }

  // **********************************************************************

  private static class Gui4jTreeMessage {
    private final String message;

<span class="nc" id="L1578">    public Gui4jTreeMessage(String message) {</span>
<span class="nc" id="L1579">      this.message = message;</span>
<span class="nc" id="L1580">    }</span>

    public String getMessage() {
<span class="nc" id="L1583">      return message;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>