<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Gui4jThreadManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gui4j</a> &gt; <a href="index.source.html" class="el_package">org.gui4j.core</a> &gt; <span class="el_source">Gui4jThreadManager.java</span></div><h1>Gui4jThreadManager.java</h1><pre class="source lang-java linenums">package org.gui4j.core;

import java.awt.EventQueue;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.util.Map;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;
import javax.swing.SwingUtilities;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.gui4j.Gui4jCallBase;
import org.gui4j.Gui4jGetValue;
import org.gui4j.exception.ErrorTags;
import org.gui4j.exception.Gui4jUncheckedException;

/**
 * The Thread Manager deals with worker threads used to perform GUI actions. The intention is to
 * take a thread from a pool, use this thread to perform the necessary action and then put the
 * thread back into the pool.
 */
public final class Gui4jThreadManager implements ErrorTags, Serializable {
  private static final long serialVersionUID = 1L;
<span class="nc" id="L33">  protected static Log mLogger = LogFactory.getLog(Gui4jThreadManager.class);</span>

  private transient ConcurrentLinkedQueue&lt;WorkPackage&gt; mWorkPackagesNormal;
  private transient ConcurrentLinkedQueue&lt;WorkPackage&gt; mWorkPackagesHighPriority;
  private transient ReentrantLock mDispatchLock;
  private transient ExecutorService mWorkerExecutor;
  private transient AtomicInteger mCreatedWorkerCount;

  protected final Gui4jInternal mGui4j;
<span class="nc" id="L42">  private final AtomicInteger mWorkPackageCountWaitingNormal = new AtomicInteger();</span>
<span class="nc" id="L43">  private final AtomicInteger mWorkPackageCountWaitingHighPriority = new AtomicInteger();</span>
<span class="nc" id="L44">  private final AtomicInteger mWorkPackageCountRunningNormal = new AtomicInteger();</span>
<span class="nc" id="L45">  private final AtomicInteger mWorkPackageCountRunningHighPriority = new AtomicInteger();</span>
  private int mMaxWorkerId;
  private int mMaxNumberOfWorkerThreads;
  private boolean mUseWorkerThreads;
  private volatile boolean mShutdownThreads;

  /**
   * Constructor for Gui4jThreadManager.
   *
   * @param gui4j
   * @param numberOfWorkerThreads
   */
  private Gui4jThreadManager(Gui4jInternal gui4j, int numberOfWorkerThreads) {
<span class="nc" id="L58">    super();</span>
<span class="nc" id="L59">    mGui4j = gui4j;</span>
<span class="nc" id="L60">    initializeTransientState();</span>
<span class="nc" id="L61">    setNumberOfWorkerThreads(numberOfWorkerThreads);</span>
<span class="nc" id="L62">  }</span>

  /**
   * @param gui4j
   * @param numberOfWorkerThreads
   * @return a new instance of the Thread Manager. This method is used only by the class &lt;code&gt;Gui4j
   *     &lt;/code&gt;.
   */
  public static Gui4jThreadManager getNewInstance(Gui4jInternal gui4j, int numberOfWorkerThreads) {
<span class="nc" id="L71">    return new Gui4jThreadManager(gui4j, numberOfWorkerThreads);</span>
  }

  /**
   * Sets the maximum number of worker threads. The value &lt;code&gt;-1&lt;/code&gt; represents an unlimited
   * number of threads. Value &lt;code&gt;0&lt;/code&gt; implies always using the Swing GUI Thread. Any number
   * greater than &lt;code&gt;0&lt;/code&gt; really sets the maximum number of worker threads. If there is work
   * to do and no worker is free, then the work is put into a FIFO queue and handled when worker
   * gets free.
   *
   * @param numberOfWorkerThreads
   */
  public void setNumberOfWorkerThreads(int numberOfWorkerThreads) {
    // it is not allowd to dynamically change the number of worker threads
<span class="nc bnc" id="L85" title="All 2 branches missed.">    assert mCreatedWorkerCount.get() == 0;</span>

<span class="nc" id="L87">    mMaxNumberOfWorkerThreads = numberOfWorkerThreads;</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">    mUseWorkerThreads = mMaxNumberOfWorkerThreads != 0;</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">    if (mUseWorkerThreads) {</span>
<span class="nc" id="L90">      mWorkerExecutor = createWorkerExecutor();</span>
    }
<span class="nc" id="L92">  }</span>

  /**
   * Performs the given work. Dependant of the number of maximum worker threads, the work is either
   * performed in the same thread, or by a new worker, or put into a FIFO queue.
   *
   * @param gui4jController
   * @param work
   * @param paramMap
   */
  public void performWork(
      final Gui4jCallBase gui4jController, final Gui4jGetValue[] work, final Map paramMap) {
<span class="nc" id="L104">    performWork(gui4jController, work, paramMap, null);</span>
<span class="nc" id="L105">  }</span>

  /**
   * Performs the given work. Dependant of the number of maximum worker threads, the work is either
   * performed in the same thread, or by a new worker, or put into a FIFO queue.
   *
   * @param gui4jController
   * @param work
   * @param paramMap
   * @param forceExecutionInCurrentThread
   */
  public void performWork(
      final Gui4jCallBase gui4jController,
      final Gui4jGetValue[] work,
      final Map paramMap,
      boolean forceExecutionInCurrentThread) {
<span class="nc" id="L121">    performWork(gui4jController, work, paramMap, null, forceExecutionInCurrentThread);</span>
<span class="nc" id="L122">  }</span>

  public void performWork(
      final Gui4jCallBase gui4jController,
      final Gui4jGetValue[] work,
      final Map paramMap,
      final Gui4jComponentInstance componentInstance) {
<span class="nc" id="L129">    performWork(gui4jController, work, paramMap, componentInstance, false);</span>
<span class="nc" id="L130">  }</span>

  public void performWorkHighPriority(
      final Gui4jCallBase gui4jController,
      final Gui4jGetValue[] work,
      final Map paramMap,
      final Gui4jComponentInstance componentInstance) {
<span class="nc" id="L137">    performWorkHighPriority(gui4jController, work, paramMap, componentInstance, false);</span>
<span class="nc" id="L138">  }</span>

  /**
   * Performs the given work. Dependant of the number of maximum worker threads, the work is either
   * performed in the same thread, or by a new worker, or put into a FIFO queue.
   *
   * @param gui4jController
   * @param work
   * @param paramMap
   * @param componentInstance
   * @param forceExecutionInCurrentThread
   */
  public void performWork(
      final Gui4jCallBase gui4jController,
      final Gui4jGetValue[] work,
      final Map paramMap,
      final Gui4jComponentInstance componentInstance,
      boolean forceExecutionInCurrentThread) {
<span class="nc" id="L156">    performWork(</span>
        gui4jController, work, paramMap, componentInstance, forceExecutionInCurrentThread, false);
<span class="nc" id="L158">  }</span>

  /**
   * Performs the specified work and instructs the worker process to use the special success
   * handling used to implement instant validation, for example.
   *
   * @param gui4jController
   * @param work
   * @param paramMap
   * @param componentInstance
   * @param forceExecutionInCurrentThread
   */
  public void performWorkSpecialSuccessHandling(
      final Gui4jCallBase gui4jController,
      final Gui4jGetValue[] work,
      final Map paramMap,
      final Gui4jComponentInstance componentInstance,
      boolean forceExecutionInCurrentThread) {
<span class="nc" id="L176">    performWork(</span>
        gui4jController,
        work,
        paramMap,
        componentInstance,
        forceExecutionInCurrentThread,
        false,
        true);
<span class="nc" id="L184">  }</span>

  /**
   * Performs the given work. Dependant of the number of maximum worker threads, the work is either
   * performed in the same thread, or by a new worker, or put into a FIFO queue.
   *
   * &lt;p&gt;Note (KKB, 12.7.2005): This method implicitly instructs the worker thread to perform special
   * success handling as in {@link #performWorkSpecialSuccessHandling(Gui4jCallBase,
   * Gui4jGetValue[], Map, Gui4jComponentInstance, boolean)}.
   *
   * @param gui4jController
   * @param work
   * @param paramMap
   * @param componentInstance
   * @param forceExecutionInCurrentThread
   */
  public void performWorkHighPriority(
      final Gui4jCallBase gui4jController,
      final Gui4jGetValue[] work,
      final Map paramMap,
      final Gui4jComponentInstance componentInstance,
      boolean forceExecutionInCurrentThread) {
<span class="nc" id="L206">    performWork(</span>
        gui4jController,
        work,
        paramMap,
        componentInstance,
        forceExecutionInCurrentThread,
        true,
        true);
<span class="nc" id="L214">  }</span>

  private void performWork(
      final Gui4jCallBase gui4jController,
      final Gui4jGetValue[] work,
      final Map paramMap,
      final Gui4jComponentInstance componentInstance,
      final boolean forceExecutionInCurrentThread,
      final boolean isHighPriorityThread) {
<span class="nc" id="L223">    performWork(</span>
        gui4jController,
        work,
        paramMap,
        componentInstance,
        forceExecutionInCurrentThread,
        isHighPriorityThread,
        false);
<span class="nc" id="L231">  }</span>

  /**
   * Perform the given work.
   *
   * @see org.gui4j.core.Gui4jThreadManager#performWork(Gui4jCallBase,Gui4jGetValue[],Map)
   * @param gui4jController
   * @param action
   * @param paramMap
   */
  public void performWork(Gui4jCallBase gui4jController, Gui4jGetValue action, Map paramMap) {
<span class="nc" id="L242">    Gui4jGetValue[] work = {action};</span>
<span class="nc" id="L243">    performWork(gui4jController, work, paramMap);</span>
<span class="nc" id="L244">  }</span>

  /**
   * Perform the given work.
   *
   * @param gui4jController
   * @param action
   * @param paramMap
   * @param componentInstance
   */
  public void performWork(
      Gui4jCallBase gui4jController,
      Gui4jGetValue action,
      Map paramMap,
      Gui4jComponentInstance componentInstance) {
<span class="nc" id="L259">    Gui4jGetValue[] work = {action};</span>
<span class="nc" id="L260">    performWork(gui4jController, work, paramMap, componentInstance);</span>
<span class="nc" id="L261">  }</span>

  /**
   * Performs the given work. Dependant of the number of maximum worker threads, the work is either
   * performed in the same thread, or by a new worker, or put into a FIFO queue.
   *
   * @param gui4jController
   * @param work
   * @param paramMap
   * @param actionHandler
   * @param forceExecutionInCurrentThread
   * @param isHighPriorityThread
   * @param specialSuccessHandling
   */
  private void performWork(
      final Gui4jCallBase gui4jController,
      final Gui4jGetValue[] work,
      final Map paramMap,
      final Gui4jComponentInstance componentInstance,
      final boolean forceExecutionInCurrentThread,
      final boolean isHighPriorityThread,
      final boolean specialSuccessHandling) {
<span class="nc bnc" id="L283" title="All 2 branches missed.">    if (mUseWorkerThreads</span>
<span class="nc bnc" id="L284" title="All 6 branches missed.">        &amp;&amp; SwingUtilities.isEventDispatchThread()</span>
        &amp;&amp; !forceExecutionInCurrentThread
        &amp;&amp; !mShutdownThreads) {
      final InvokerCallStack callStack =
<span class="nc bnc" id="L288" title="All 2 branches missed.">          mGui4j.traceWorkerInvocation()</span>
<span class="nc" id="L289">              ? new InvokerCallStack(Thread.currentThread().getName())</span>
<span class="nc" id="L290">              : null;</span>
<span class="nc" id="L291">      final WorkPackage workPackage =</span>
          new WorkPackage(
              gui4jController,
              work,
              paramMap,
              componentInstance,
              callStack,
              isHighPriorityThread,
              specialSuccessHandling);
<span class="nc" id="L300">      Runnable run =</span>
<span class="nc" id="L301">          new Runnable() {</span>
            public void run() {
<span class="nc bnc" id="L303" title="All 2 branches missed.">              if (isHighPriorityThread) {</span>
<span class="nc" id="L304">                mWorkPackagesHighPriority.add(workPackage);</span>
<span class="nc" id="L305">                mWorkPackageCountWaitingHighPriority.incrementAndGet();</span>
              } else {
<span class="nc" id="L307">                mWorkPackagesNormal.add(workPackage);</span>
<span class="nc" id="L308">                mWorkPackageCountWaitingNormal.incrementAndGet();</span>
              }
<span class="nc" id="L310">              dispatchPendingWork();</span>
<span class="nc" id="L311">            }</span>
          };
<span class="nc" id="L313">      SwingUtilities.invokeLater(run);</span>
<span class="nc" id="L314">    } else {</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">      for (int i = 0; i &lt; work.length; i++) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (work[i] != null) {</span>
<span class="nc" id="L317">          work[i].getValue(gui4jController, paramMap, null);</span>
        }
      }
    }
<span class="nc" id="L321">  }</span>

  public void shutdown() {
<span class="nc" id="L324">    mShutdownThreads = true;</span>
<span class="nc" id="L325">    ExecutorService executor = mWorkerExecutor;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">    if (executor != null) {</span>
<span class="nc" id="L327">      executor.shutdownNow();</span>
    }
<span class="nc" id="L329">  }</span>

  private void dispatchPendingWork() {
<span class="nc bnc" id="L332" title="All 6 branches missed.">    if (!mUseWorkerThreads || mShutdownThreads || mWorkerExecutor == null) {</span>
<span class="nc" id="L333">      return;</span>
    }
<span class="nc bnc" id="L335" title="All 2 branches missed.">    if (!mDispatchLock.tryLock()) {</span>
<span class="nc" id="L336">      return;</span>
    }
    try {
<span class="nc bnc" id="L339" title="All 2 branches missed.">      while (!mShutdownThreads) {</span>
<span class="nc" id="L340">        WorkPackage workPackage = pollNextWorkPackage();</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (workPackage == null) {</span>
<span class="nc" id="L342">          return;</span>
        }
<span class="nc" id="L344">        submitWorkPackage(workPackage);</span>
<span class="nc" id="L345">      }</span>
    } finally {
<span class="nc" id="L347">      mDispatchLock.unlock();</span>
    }
<span class="nc" id="L349">  }</span>

  private WorkPackage pollNextWorkPackage() {
<span class="nc bnc" id="L352" title="All 2 branches missed.">    if (mWorkPackageCountRunningHighPriority.get() &gt; 0) {</span>
<span class="nc" id="L353">      WorkPackage high = mWorkPackagesHighPriority.poll();</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">      if (high != null) {</span>
<span class="nc" id="L355">        mWorkPackageCountWaitingHighPriority.decrementAndGet();</span>
<span class="nc" id="L356">        mWorkPackageCountRunningHighPriority.incrementAndGet();</span>
      }
<span class="nc" id="L358">      return high;</span>
    }

<span class="nc" id="L361">    WorkPackage high = mWorkPackagesHighPriority.poll();</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">    if (high != null) {</span>
<span class="nc" id="L363">      mWorkPackageCountWaitingHighPriority.decrementAndGet();</span>
<span class="nc" id="L364">      mWorkPackageCountRunningHighPriority.incrementAndGet();</span>
<span class="nc" id="L365">      return high;</span>
    }

<span class="nc" id="L368">    WorkPackage normal = mWorkPackagesNormal.poll();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">    if (normal != null) {</span>
<span class="nc" id="L370">      mWorkPackageCountWaitingNormal.decrementAndGet();</span>
<span class="nc" id="L371">      mWorkPackageCountRunningNormal.incrementAndGet();</span>
    }
<span class="nc" id="L373">    return normal;</span>
  }

  private void submitWorkPackage(final WorkPackage workPackage) {
<span class="nc bnc" id="L377" title="All 2 branches missed.">    if (mLogger.isDebugEnabled()) {</span>
<span class="nc" id="L378">      mLogger.debug(</span>
          &quot;Submitting work package &quot;
<span class="nc bnc" id="L380" title="All 2 branches missed.">              + (workPackage.mIsHighPriority ? &quot;(high prio)&quot; : &quot;&quot;)</span>
              + &quot;. Current work queue: RunningHighPriority: &quot;
<span class="nc" id="L382">              + mWorkPackageCountRunningHighPriority.get()</span>
              + &quot;, WaitingHighPriority: &quot;
<span class="nc" id="L384">              + mWorkPackageCountWaitingHighPriority.get()</span>
              + &quot;, RunningNormal: &quot;
<span class="nc" id="L386">              + mWorkPackageCountRunningNormal.get()</span>
              + &quot;, WaitingNormal: &quot;
<span class="nc" id="L388">              + mWorkPackageCountWaitingNormal.get());</span>
    }

<span class="nc" id="L391">    mWorkerExecutor.execute(</span>
<span class="nc" id="L392">        new Runnable() {</span>
          public void run() {
<span class="nc" id="L394">            WorkerThread workerThread = null;</span>
<span class="nc" id="L395">            Thread t = Thread.currentThread();</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (t instanceof WorkerThread) {</span>
<span class="nc" id="L397">              workerThread = (WorkerThread) t;</span>
<span class="nc" id="L398">              workerThread.setWorkPackage(workPackage);</span>
            }
            try {
<span class="nc bnc" id="L401" title="All 2 branches missed.">              for (int i = 0; i &lt; workPackage.mWork.length; i++) {</span>
<span class="nc" id="L402">                doWork(workPackage.mWork[i], workPackage, i);</span>
              }
<span class="nc bnc" id="L404" title="All 2 branches missed.">              if (mLogger.isDebugEnabled()) {</span>
<span class="nc" id="L405">                mLogger.debug(Thread.currentThread().getName() + &quot;: work finished.&quot;);</span>
              }
            } finally {
<span class="nc bnc" id="L408" title="All 2 branches missed.">              if (workPackage.mIsHighPriority) {</span>
<span class="nc" id="L409">                mWorkPackageCountRunningHighPriority.decrementAndGet();</span>
              } else {
<span class="nc" id="L411">                mWorkPackageCountRunningNormal.decrementAndGet();</span>
              }
<span class="nc bnc" id="L413" title="All 2 branches missed.">              if (workerThread != null) {</span>
<span class="nc" id="L414">                workerThread.setWorkPackage(null);</span>
              }
<span class="nc" id="L416">              dispatchPendingWork();</span>
            }
<span class="nc" id="L418">          }</span>
        });
<span class="nc" id="L420">  }</span>

  private void doWork(Gui4jGetValue work, WorkPackage workPackage, int i) {
<span class="nc bnc" id="L423" title="All 2 branches missed.">    if (work == null) {</span>
<span class="nc" id="L424">      return;</span>
    }
<span class="nc bnc" id="L426" title="All 2 branches missed.">    if (mLogger.isDebugEnabled()) {</span>
<span class="nc" id="L427">      mLogger.trace(</span>
<span class="nc" id="L428">          Thread.currentThread().getName()</span>
              + &quot;: performing work &quot;
<span class="nc bnc" id="L430" title="All 2 branches missed.">              + (workPackage.mIsHighPriority ? &quot;(high prio)&quot; : &quot;&quot;)</span>
              + &quot;: &quot;
              + work);
    }
    try {
<span class="nc" id="L435">      work.getValueNoErrorChecking(</span>
          workPackage.mGui4jController, workPackage.mParamMap, workPackage.mComponentInstance);
      // Falls verlangt, rufen wir
      // (nur nach dem ersten Aufruf) die
      // &lt;code&gt;handleSuccess&lt;/code&gt;
      // Methode auf.
      // Beim Edit-Feld wird damit im Ok-Fall der
      // Inhalt nochmals
      // angezeigt. Au√üerdem kann damit Validierung
      // gemacht werden.
<span class="nc bnc" id="L445" title="All 6 branches missed.">      if (i == 0 &amp;&amp; workPackage.mSpecialSuccessHandling &amp;&amp; workPackage.mComponentInstance != null) {</span>
<span class="nc" id="L446">        workPackage.mComponentInstance.handleSuccess();</span>
      }
<span class="nc" id="L448">    } catch (Throwable t) {</span>
      // Analog zum Ok-Fall, rufen wir im Fehlerfall
      // nach dem ersten
      // Aufruf die &lt;code&gt;handleException&lt;/code&gt;
      // Methode auf. Damit
      // kann beispielsweise Validierung gemacht
      // werden.
<span class="nc bnc" id="L455" title="All 6 branches missed.">      if (i == 0 &amp;&amp; workPackage.mSpecialSuccessHandling &amp;&amp; workPackage.mComponentInstance != null) {</span>
<span class="nc" id="L456">        workPackage.mComponentInstance.handleException(t);</span>
      } else {
        // Falls kein ActionHandler definiert wurde,
        // oder
        // es sich nicht um den ersten Aufruf
        // handelt,
        // erfolgt die normale Fehlerbehandlung.
<span class="nc" id="L463">        mGui4j.handleException(workPackage.mGui4jController, t, null);</span>
      }
<span class="nc" id="L465">    }</span>
<span class="nc" id="L466">  }</span>

  private static class WorkPackage {
    public final Gui4jCallBase mGui4jController;
    public final Gui4jGetValue[] mWork;
    public final Gui4jComponentInstance mComponentInstance;
    public final Map mParamMap;
    public final InvokerCallStack mCallStack;
    public final boolean mSpecialSuccessHandling;
    public final boolean mIsHighPriority;

    public WorkPackage(
        Gui4jCallBase gui4jController,
        Gui4jGetValue[] work,
        Map paramMap,
        Gui4jComponentInstance componentInstance,
        InvokerCallStack callStack,
        boolean isHighPriority,
<span class="nc" id="L484">        boolean specialSuccessHandling) {</span>
<span class="nc" id="L485">      mGui4jController = gui4jController;</span>
<span class="nc" id="L486">      mWork = work;</span>
<span class="nc" id="L487">      mParamMap = paramMap;</span>
<span class="nc" id="L488">      mComponentInstance = componentInstance;</span>
<span class="nc" id="L489">      mCallStack = callStack;</span>
<span class="nc" id="L490">      mIsHighPriority = isHighPriority;</span>
<span class="nc" id="L491">      mSpecialSuccessHandling = specialSuccessHandling;</span>
<span class="nc" id="L492">    }</span>
  }

  public class WorkerThread extends Thread {
    private volatile WorkPackage mWorkPackage;
    private final int mId;

<span class="nc" id="L499">    public WorkerThread(int id, Runnable target) {</span>
<span class="nc" id="L500">      super(target);</span>
<span class="nc" id="L501">      mId = id;</span>

      // This thread will be created by the AWT thread and we have to make
      // sure we don't use the AWT thread's privileged priority.
<span class="nc" id="L505">      setPriority(NORM_PRIORITY);</span>

<span class="nc" id="L507">      setName(&quot;Gui4j-Worker &quot; + mId);</span>
<span class="nc" id="L508">      mLogger.debug(this + &quot;: created&quot;);</span>
<span class="nc" id="L509">    }</span>

    public Throwable getCallStack() {
<span class="nc bnc" id="L512" title="All 2 branches missed.">      return mWorkPackage != null ? mWorkPackage.mCallStack : null;</span>
    }

    private void setWorkPackage(WorkPackage workPackage) {
<span class="nc" id="L516">      mWorkPackage = workPackage;</span>
<span class="nc" id="L517">    }</span>

    public String toString() {
<span class="nc" id="L520">      return getName();</span>
    }
  }

  private static class InvokerCallStack extends Throwable {
    public InvokerCallStack(String threadName) {
<span class="nc" id="L526">      super(threadName);</span>
<span class="nc" id="L527">    }</span>

    public String toString() {
<span class="nc" id="L530">      return &quot;Thread [&quot; + getMessage() + &quot;]&quot;;</span>
    }
  }

  /**
   * If the calling thread is the AWT Event Dispatch Thread (EDT) the specified command is executed
   * and this method returns after completion of the command. If the calling thread is not the EDT,
   * the given &lt;code&gt;Runnable&lt;/code&gt; is inserted into the AWT EventQueue via &lt;code&gt;
   * EventQueue.invokeAndWait()&lt;/code&gt;. In this case, this call does not return until the EDT has
   * completed the queued task.
   *
   * @param run task to be scheduled in the GUI thread
   */
  public static void executeInSwingThreadAndWait(Runnable run) {
    try {
<span class="nc bnc" id="L545" title="All 2 branches missed.">      if (EventQueue.isDispatchThread()) {</span>
        // if we already are in the EDT we simply execute the command
<span class="nc" id="L547">        run.run();</span>
      } else {
<span class="nc" id="L549">        EventQueue.invokeAndWait(run);</span>
      }
<span class="nc" id="L551">    } catch (InterruptedException ex) {</span>
<span class="nc" id="L552">      mLogger.warn(&quot;Interrupted&quot;, ex);</span>
<span class="nc" id="L553">    } catch (InvocationTargetException ex) {</span>
<span class="nc" id="L554">      Gui4jReflectionManager.handleInvocationTargetException(ex);</span>
<span class="nc" id="L555">      throw new Gui4jUncheckedException.ProgrammingError(</span>
          PROGRAMMING_ERROR_invocation_target_exception, ex);
<span class="nc" id="L557">    }</span>
<span class="nc" id="L558">  }</span>

  /**
   * The given task is executed in the GUI thread as soon as possible. There are two cases: &lt;br&gt;
   * If this thread is not the GUI thread, the given &lt;code&gt;Runnable&lt;/code&gt; is inserted into the task
   * queue of the GUI thread. This call then returns immediately without waiting for the scheduled
   * task to be finished. &lt;br&gt;
   * If this thread is the GUI thread itself, the given task is executed immediately and
   * synchronously, i.e. this call will not return until the task is completed.
   *
   * @param run task to be scheduled in the GUI thread
   */
  public static void executeInSwingThreadAndContinue(final Runnable run) {
<span class="nc bnc" id="L571" title="All 2 branches missed.">    if (EventQueue.isDispatchThread()) {</span>
<span class="nc" id="L572">      run.run();</span>
    } else {
<span class="nc" id="L574">      EventQueue.invokeLater(run);</span>
    }
<span class="nc" id="L576">  }</span>

  private ExecutorService createWorkerExecutor() {
<span class="nc" id="L579">    ThreadFactory workerFactory =</span>
<span class="nc" id="L580">        new ThreadFactory() {</span>
          public Thread newThread(Runnable runnable) {
<span class="nc" id="L582">            mCreatedWorkerCount.incrementAndGet();</span>
<span class="nc" id="L583">            return new WorkerThread(mMaxWorkerId++, runnable);</span>
          }
        };

<span class="nc bnc" id="L587" title="All 2 branches missed.">    if (mMaxNumberOfWorkerThreads == -1) {</span>
<span class="nc" id="L588">      return new ThreadPoolExecutor(</span>
          0,
          Integer.MAX_VALUE,
          60L,
          TimeUnit.SECONDS,
          new SynchronousQueue&lt;Runnable&gt;(),
          workerFactory);
    }

<span class="nc" id="L597">    return new ThreadPoolExecutor(</span>
        mMaxNumberOfWorkerThreads,
        mMaxNumberOfWorkerThreads,
        0L,
        TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue&lt;Runnable&gt;(),
        workerFactory);
  }

  private void initializeTransientState() {
<span class="nc" id="L607">    mWorkPackagesNormal = new ConcurrentLinkedQueue&lt;WorkPackage&gt;();</span>
<span class="nc" id="L608">    mWorkPackagesHighPriority = new ConcurrentLinkedQueue&lt;WorkPackage&gt;();</span>
<span class="nc" id="L609">    mDispatchLock = new ReentrantLock();</span>
<span class="nc" id="L610">    mCreatedWorkerCount = new AtomicInteger();</span>
<span class="nc" id="L611">    mShutdownThreads = false;</span>
<span class="nc" id="L612">  }</span>

  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="nc" id="L615">    in.defaultReadObject();</span>
<span class="nc" id="L616">    initializeTransientState();</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">    if (mUseWorkerThreads) {</span>
<span class="nc" id="L618">      mWorkerExecutor = createWorkerExecutor();</span>
    }
<span class="nc" id="L620">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>